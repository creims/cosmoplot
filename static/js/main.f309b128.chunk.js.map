{"version":3,"sources":["Draw.tsx","CanvasProps.tsx","GridCanvas.tsx","PlotCanvas.tsx","Graph.tsx","Point.tsx","App.tsx","index.tsx"],"names":["radius","connectPts","ctx","points","cycle","length","cur","first","beginPath","moveTo","x","y","i","lineTo","stroke","useCanvasRefs","useState","setCtx","useCallback","canvas","getContext","getIncrements","viewport","width","height","inc","minTicks","span","log","Math","log10","pow10","pow","floor","div","getIncrement","max","extent","worldIncrements","dx","dy","deviceIncrements","xOffset","abs","min","yOffset","worldStarts","deviceStarts","formatNumber","n","round","toString","drawAxisLabel","label","offsetX","m","measureText","fillStyle","fillRect","fillText","GridCanvas","props","canvasRef","increments","useEffect","data","clearRect","strokeStyle","textBaseline","textAlign","font","labelY","halfInc","strokeRect","labelX","drawGraph","ref","className","PlotCanvas","type","left","cp1","cp2","end","bezierCurveTo","cp","quadraticCurveTo","drawLine","lineType","forEach","point","index","style","activePoint","location","arc","PI","fill","drawPoint","scaleViewport","v","ratio","Graph","windowX","windowY","undefined","setActivePoint","ptrDown","setPtrDown","worldPoints","setWorldPoints","devicePoints","setDevicePoints","ratioX","ratioY","xMin","xMax","yMin","yMax","getRegularViewport","setViewport","lineStyle","setLineStyle","toWorld","toDevice","map","onPointerDown","e","clicked","clientX","clientY","newActivePoint","loc","dist","a","b","sqrt","distance","onPointerMove","xRatio","movementX","yRatio","movementY","clickedPoint","newWorld","slice","onPointerUp","onDoubleClick","newDevicePoint","onWheel","deltaY","id","onChange","target","value","App","renderApp","ReactDOM","render","window","innerWidth","innerHeight","document","getElementById","addEventListener"],"mappings":"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","file":"static/js/main.f309b128.chunk.js","sourcesContent":["import {Point} from './Point';\r\nimport {LineStyle} from \"./types\";\r\n\r\nexport const radius: number = 5;\r\n\r\nexport function drawPoint(ctx: CanvasRenderingContext2D, location: Point, style: string) {\r\n    ctx.fillStyle = style;\r\n    ctx.beginPath();\r\n    ctx.arc(location.x, location.y, radius, 0, Math.PI * 2);\r\n    ctx.fill();\r\n}\r\n\r\nfunction connectPts(ctx: CanvasRenderingContext2D, points: Point[], cycle: boolean) {\r\n    if(points.length < 2) return;\r\n    const first = points[0];\r\n    let cur;\r\n\r\n    ctx.beginPath();\r\n    ctx.moveTo(first.x, first.y);\r\n    for(let i = 1; i < points.length; i++) {\r\n        cur = points[i];\r\n        ctx.lineTo(cur.x, cur.y);\r\n    }\r\n\r\n    if(cycle) ctx.lineTo(first.x, first.y);\r\n\r\n    ctx.stroke();\r\n}\r\n\r\nexport function drawLine(ctx: CanvasRenderingContext2D, points: Point[], type: LineStyle) {\r\n    switch (type) {\r\n        case 'bezier':\r\n            ctx.beginPath();\r\n            for(let i = 0; i < points.length;) {\r\n                const left = points.length - i;\r\n                ctx.moveTo(points[i].x, points[i].y);\r\n                if (left >= 4) {\r\n                    const cp1 = points[i + 1];\r\n                    const cp2 = points[i + 2];\r\n                    const end = points[i + 3];\r\n                    ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, end.x, end.y);\r\n                    i += 3;\r\n                } else if (left === 3) {\r\n                    const cp = points[i + 1];\r\n                    const end = points[i + 2];\r\n                    ctx.quadraticCurveTo(cp.x, cp.y, end.x, end.y);\r\n                    i += 2;\r\n                } else if(left === 2) {\r\n                    const end = points[i + 1];\r\n                    ctx.lineTo(end.x, end.y);\r\n                    i++;\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n            ctx.stroke();\r\n            break;\r\n        case 'cycle':\r\n            connectPts(ctx, points, true);\r\n            break;\r\n        case 'line':\r\n            connectPts(ctx, points, false);\r\n            break;\r\n        default: // Do nothing with plot types\r\n            break;\r\n    }\r\n}\r\n\r\n\r\n","import {useCallback, useState} from \"react\";\r\nimport {CanvasRefs} from \"./types\";\r\n\r\n// We use a callback hook to store the context as state\r\n// This avoids calling ref.getContext every time we update the canvas\r\nexport function useCanvasRefs(): CanvasRefs {\r\n    const [ctx, setCtx] = useState<CanvasRenderingContext2D | null>(null);\r\n    // Called when a canvas is mounted\r\n    const callback = useCallback((canvas: HTMLCanvasElement) => {\r\n        if (canvas !== null) {\r\n            setCtx(canvas.getContext('2d'));\r\n        }\r\n    }, []);\r\n\r\n    return [ctx, callback];\r\n}\r\n","import React, {useEffect} from 'react';\r\nimport {useCanvasRefs} from \"./CanvasProps\";\r\nimport {Viewport, GraphData} from \"./types\";\r\n\r\ntype GraphBackgroundProps = {\r\n    width: number,\r\n    height: number,\r\n    viewport: Viewport\r\n};\r\n\r\n// Pick the largest tick increment which is 1, 2, or 5 times a power of 10\r\nfunction getIncrement(minTicks: number, span: number): number {\r\n    const log = Math.log10(span / minTicks);\r\n\r\n    const pow10 = Math.pow(10, Math.floor(log));\r\n    const div = span / (pow10 * minTicks);\r\n\r\n    if (div > 5) return pow10 * 5;\r\n    if (div > 2) return pow10 * 2;\r\n    return pow10;\r\n}\r\n\r\nfunction getIncrements(viewport: Viewport, width: number, height: number): GraphData {\r\n    const minTicks: number = 14;\r\n\r\n    //const worldIncrements = {dx: getIncrement(minTicks, xSpan), dy: getIncrement(minTicks, ySpan)};]\r\n    const span = Math.max(viewport.x.extent, viewport.y.extent);\r\n    const inc = getIncrement(minTicks, span);\r\n    const worldIncrements = {dx: inc, dy: inc};\r\n    const deviceDX = width / (viewport.x.extent / worldIncrements.dx);\r\n    const deviceDY = height / (viewport.y.extent / worldIncrements.dy);\r\n    const deviceIncrements = {dx: deviceDX, dy: deviceDY};\r\n\r\n    // First tick is usually not exactly at the baseline\r\n    let xOffset = Math.abs(viewport.x.min) % inc;\r\n    let yOffset = Math.abs(viewport.y.min) % inc;\r\n\r\n    xOffset = viewport.x.min > 0 ? -xOffset : xOffset;\r\n    yOffset = viewport.y.min > 0 ? -yOffset : yOffset;\r\n\r\n    // First tick is at min + offset\r\n    const worldStarts = {x: xOffset + viewport.x.min, y: yOffset + viewport.y.min};\r\n    const deviceStarts = {x: xOffset / viewport.x.extent * width, y: yOffset / viewport.y.extent * height};\r\n\r\n    return {worldStarts, deviceStarts, worldIncrements, deviceIncrements};\r\n}\r\n\r\n// Format the number, chop off rounding errors, etc\r\n// TODO: find complete solution that dodges floating point issues; as this one fails due to rounding and at certain sizes\r\n// Possibility: store the increment as an int, multiply by tick amount, then manually add zeroes on either side\r\nfunction formatNumber(n: number): string {\r\n    return (Math.round(n * 1000) / 1000).toString();\r\n}\r\n\r\nfunction drawAxisLabel(ctx: CanvasRenderingContext2D, label: string, x: number, y: number, offsetX: boolean): void {\r\n    const m: TextMetrics = ctx.measureText(label);\r\n    if(offsetX) x += m.width / 2;\r\n    ctx.fillStyle = 'white';\r\n    ctx.fillRect(x - m.width / 2, y - 8, m.width, 16);\r\n    ctx.fillStyle = 'black';\r\n    ctx.fillText(label, x, y);\r\n}\r\n\r\nfunction drawGraph(ctx: CanvasRenderingContext2D, width: number, height: number, data: GraphData) {\r\n    if (ctx === null) return;\r\n\r\n    ctx.clearRect(0, 0, width, height);\r\n    ctx.strokeStyle = 'gray';\r\n    ctx.textBaseline = 'middle';\r\n    ctx.textAlign = 'center';\r\n    ctx.font = '16px monospace';\r\n\r\n    // Do Y axis first so the horizontal gridlines get cleared properly by drawAxisLabel\r\n    // TODO: figure out better solution for labeling\r\n    let labelY = data.worldStarts.y;\r\n    let halfInc = data.worldIncrements.dy / 2;\r\n    for (let y = height - data.deviceStarts.y; y >= 0; y -= data.deviceIncrements.dy) {\r\n        if (labelY + halfInc > 0 && labelY - halfInc < 0) {\r\n            ctx.strokeStyle = 'black';\r\n            ctx.strokeRect(0, y, width, 0.8);\r\n            ctx.strokeStyle = 'gray';\r\n        } else {\r\n            ctx.strokeRect(0, y, width, 0.1);\r\n        }\r\n\r\n        drawAxisLabel(ctx, formatNumber(labelY), 0, y, true);\r\n        labelY += data.worldIncrements.dy;\r\n    }\r\n\r\n    let labelX = data.worldStarts.x;\r\n    halfInc = data.worldIncrements.dx / 2;\r\n    for (let x = data.deviceStarts.x; x < width; x += data.deviceIncrements.dx) {\r\n        if (labelX + halfInc > 0 && labelX - halfInc < 0) {\r\n            ctx.strokeStyle = 'black';\r\n            ctx.strokeRect(x, 0, 0.8, height);\r\n            ctx.strokeStyle = 'gray';\r\n        } else {\r\n            ctx.strokeRect(x, 0, 0.1, height);\r\n        }\r\n\r\n        drawAxisLabel(ctx, formatNumber(labelX), x, 10, false);\r\n        labelX += data.worldIncrements.dx;\r\n    }\r\n}\r\n\r\nconst GridCanvas: React.FC<GraphBackgroundProps> = (props: GraphBackgroundProps) => {\r\n    const [ctx, canvasRef] = useCanvasRefs();\r\n    const increments = getIncrements(props.viewport, props.width, props.height);\r\n\r\n    useEffect(() => {\r\n        if (ctx === null) return;\r\n        drawGraph(ctx, props.width, props.height, increments);\r\n    }, [ctx, props, increments]);\r\n\r\n    return <canvas\r\n        ref={canvasRef}\r\n        width={props.width}\r\n        height={props.height}\r\n        className='fixed layer-bottom'\r\n    />\r\n};\r\n\r\nexport default GridCanvas;","import React, {useEffect} from 'react';\r\nimport {Point} from \"./Point\";\r\nimport {useCanvasRefs} from \"./CanvasProps\";\r\nimport {drawLine, drawPoint} from './Draw';\r\nimport {LineStyle} from \"./types\";\r\n\r\ntype PlotCanvasProps = {\r\n    width: number,\r\n    height: number,\r\n    points: Point[],\r\n    activePoint: number | undefined,\r\n    lineType: LineStyle\r\n};\r\n\r\nconst PlotCanvas: React.FC<PlotCanvasProps> = (props: PlotCanvasProps) => {\r\n    const [ctx, canvasRef] = useCanvasRefs();\r\n\r\n    useEffect(() => {\r\n        if (ctx === null) return;\r\n\r\n        ctx.clearRect(0, 0, props.width, props.height);\r\n        drawLine(ctx, props.points, props.lineType);\r\n        props.points.forEach((point, index) => {\r\n            let style: string;\r\n            if (index === props.activePoint) {\r\n                style = 'red';\r\n            } else {\r\n                style = 'blue';\r\n            }\r\n\r\n            drawPoint(ctx, point, style);\r\n        });\r\n    }, [ctx, props.points, props.activePoint, props.width, props.height, props.lineType]);\r\n\r\n    return <canvas\r\n        ref={canvasRef}\r\n        width={props.width}\r\n        height={props.height}\r\n        className='fixed layer-middle'\r\n    />\r\n};\r\n\r\nexport default PlotCanvas;","import React, {useCallback, useEffect, useState} from 'react';\r\nimport {Point, distance} from './Point';\r\nimport {radius} from './Draw';\r\nimport GridCanvas from './GridCanvas';\r\nimport PlotCanvas from './PlotCanvas';\r\nimport {Dimensions, LineStyle, Viewport} from \"./types\";\r\n\r\nfunction getRegularViewport(min: number, max: number, windowX: number, windowY: number): Viewport {\r\n    let ratioX: number = 1;\r\n    let ratioY: number = 1;\r\n    if (windowX > windowY) {\r\n        ratioY = windowY / windowX;\r\n    } else {\r\n        ratioX = windowX / windowY;\r\n    }\r\n\r\n    const xMin = min * ratioX;\r\n    const xMax = max * ratioX;\r\n    const yMin = min * ratioY;\r\n    const yMax = max * ratioY;\r\n\r\n    return {\r\n        x: {min: xMin, max: xMax, extent: xMax - xMin},\r\n        y: {min: yMin, max: yMax, extent: yMax - yMin}\r\n    };\r\n}\r\n\r\nfunction getDefaultViewport(windowX: number, windowY: number) : Viewport {\r\n    return getRegularViewport(-10.5, 10.5, windowX, windowY);\r\n}\r\n\r\nfunction scaleViewport(v: Viewport, ratio: number) {\r\n    return {\r\n      x: {min: v.x.min * ratio, max: v.x.max * ratio, extent: v.x.extent * ratio},\r\n      y: {min: v.y.min * ratio, max: v.y.max * ratio, extent: v.y.extent * ratio}\r\n    };\r\n}\r\n\r\nconst Graph: React.FC<Dimensions> = (props: Dimensions) => {\r\n    const [activePoint, setActivePoint] = useState<number | undefined>(undefined);\r\n    const [ptrDown, setPtrDown] = useState<boolean>(false);\r\n    const [worldPoints, setWorldPoints] = useState<Point[]>([]);\r\n    const [devicePoints, setDevicePoints] = useState<Point[]>([]);\r\n    const [viewport, setViewport] = useState<Viewport>(getDefaultViewport(props.width, props.height));\r\n    const [lineStyle, setLineStyle] = useState<LineStyle>('bezier');\r\n\r\n    // We store world coordinates and convert back to device coordinates to display\r\n    function toWorld(point: Point): Point {\r\n        return {\r\n            x: point.x / props.width * viewport.x.extent + viewport.x.min,\r\n            y: (props.height - point.y) / props.height * viewport.y.extent + viewport.y.min\r\n        };\r\n    }\r\n\r\n    // We wrap toDevice conversion with useCallback so that the useEffect below has static dependencies\r\n    const toDevice = useCallback((point: Point) => {\r\n        return {\r\n            x: Math.round((point.x - viewport.x.min) / viewport.x.extent * props.width),\r\n            y: Math.round(props.height - ((point.y - viewport.y.min) / viewport.y.extent * props.height))\r\n        };\r\n    }, [props.width, props.height, viewport]);\r\n\r\n    // When worldPoints changes, update devicePoints to trigger a redraw\r\n    useEffect(() => {\r\n        setDevicePoints(worldPoints.map(toDevice));\r\n    }, [toDevice, worldPoints]);\r\n\r\n    function handlePointerDown(e: React.PointerEvent) {\r\n        // Set the active point\r\n        // New active point should be the one closest to click, but only if a point is close enough\r\n        let min: number = radius;\r\n        const clicked: Point = {x: e.clientX, y: e.clientY};\r\n        let newActivePoint: number | undefined = undefined;\r\n        devicePoints.forEach((loc, index) => {\r\n            const dist = distance(clicked, loc);\r\n            if (dist < min) {\r\n                newActivePoint = index;\r\n                min = dist;\r\n            }\r\n        });\r\n\r\n        if (activePoint !== newActivePoint) {\r\n            setActivePoint(newActivePoint);\r\n        }\r\n\r\n        setPtrDown(true);\r\n    }\r\n\r\n    function handlePointerMove(e: React.PointerEvent) {\r\n        if (!ptrDown) return;\r\n\r\n        if (activePoint === undefined) { // Pan the graph\r\n            const xRatio = e.movementX / props.width;\r\n            const dx = (viewport.x.max - viewport.x.min) * xRatio;\r\n            const xMin = viewport.x.min - dx;\r\n            const xMax = viewport.x.max - dx;\r\n\r\n            const yRatio = e.movementY / props.height;\r\n            const dy = (viewport.y.max - viewport.y.min) * yRatio;\r\n            const yMin = viewport.y.min + dy;\r\n            const yMax = viewport.y.max + dy;\r\n\r\n            setViewport({\r\n                x: {min: xMin, max: xMax, extent: xMax - xMin},\r\n                y: {min: yMin, max: yMax, extent: yMax - yMin}\r\n            });\r\n        } else { // Move the point\r\n            // TODO: optimization: use reducer for points since useState does not merge lists\r\n            const clickedPoint = {x: e.clientX, y: e.clientY};\r\n            const newWorld = worldPoints.slice();\r\n            newWorld[activePoint] = toWorld(clickedPoint);\r\n\r\n            setWorldPoints(newWorld);\r\n        }\r\n    }\r\n\r\n    function handlePointerUp(e: React.PointerEvent) {\r\n        setPtrDown(false);\r\n    }\r\n\r\n    function handleDoubleClick(e: React.MouseEvent) {\r\n        const newDevicePoint: Point = {x: e.clientX, y: e.clientY};\r\n        setActivePoint(worldPoints.length);\r\n        setDevicePoints([...devicePoints, newDevicePoint]);\r\n        setWorldPoints([...worldPoints, toWorld(newDevicePoint)]);\r\n    }\r\n\r\n    function handleWheel(e: React.WheelEvent) {\r\n        if(e.deltaY === 0) return;\r\n\r\n        if(e.deltaY > 0) { // Scroll down (towards)\r\n            setViewport(scaleViewport(viewport, 1.2));\r\n        } else { // Scroll up (away)\r\n            setViewport(scaleViewport(viewport, 0.8));\r\n        }\r\n    }\r\n\r\n    return <>\r\n        <div\r\n            style={{\r\n                width: props.width,\r\n                height: props.height\r\n            }}\r\n\r\n            onPointerDown={handlePointerDown}\r\n            onPointerMove={handlePointerMove}\r\n            onPointerUp={handlePointerUp}\r\n            onDoubleClick={handleDoubleClick}\r\n            onWheel={handleWheel}\r\n            className='fixed layer-top'\r\n        />\r\n        <GridCanvas\r\n            width={props.width}\r\n            height={props.height}\r\n            viewport={viewport}\r\n        />\r\n        <PlotCanvas\r\n            width={props.width}\r\n            height={props.height}\r\n            points={devicePoints}\r\n            activePoint={activePoint}\r\n            lineType={lineStyle}\r\n        />\r\n        <select\r\n        className='layer-control'\r\n        id='line-style'\r\n        onChange={e => { setLineStyle(e.target.value as LineStyle); }}\r\n        >\r\n        <option value={'bezier'}>Bezier</option>\r\n        <option value={'line'}>Line</option>\r\n        <option value={'cycle'}>Cycle</option>\r\n        <option value={'plot'}>Plot</option>\r\n    </select>\r\n    </>\r\n};\r\n\r\nexport default Graph;","export interface Point {\r\n    x: number;\r\n    y: number;\r\n}\r\n\r\nexport function distance(a: Point, b: Point) : number {\r\n    const dx = b.x - a.x;\r\n    const dy = b.y - a.y;\r\n    return Math.sqrt(dx * dx + dy * dy);\r\n}\r\n","import React from 'react';\nimport Graph from './Graph';\nimport './App.css';\n\ninterface WindowDimensions {\n    width: number;\n    height: number;\n}\n\nconst App: React.FC<WindowDimensions> = (props: WindowDimensions) => {\n    return (\n        <>\n            <Graph\n                width={props.width}\n                height={props.height}\n            />\n        </>\n    );\n};\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nfunction renderApp() {\n    ReactDOM.render(<App width={window.innerWidth} height={window.innerHeight} />, document.getElementById('root'));\n}\n\nwindow.addEventListener('resize', renderApp);\n\nrenderApp();\n"],"sourceRoot":""}