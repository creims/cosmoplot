{"version":3,"sources":["fitcurve.tsx","Draw.tsx","hooks.tsx","GridCanvas.tsx","PlotCanvas.tsx","Graph.tsx","Point.tsx","App.tsx","index.tsx"],"names":["computeControlPoints","knots","cp1","cp2","n","length","a","b","c","r","i","m","radius","connectPts","ctx","points","cycle","minor","cur","first","beginPath","strokeStyle","lineWidth","moveTo","x","y","lineTo","stroke","drawBezier","start","end","bezierCurveTo","drawQuadratic","cp","quadraticCurveTo","piecewiseCubicBezier","drawHandles","left","drawLine","type","slice","push","xCPs","map","p","yCPs","cubicCPs","fitCurve","useCanvasRefs","useState","setCtx","useCallback","canvas","getContext","getIncrements","viewport","width","height","inc","minTicks","span","log","Math","log10","pow10","pow","floor","div","getIncrement","max","extent","worldIncrements","dx","dy","deviceIncrements","xOffset","abs","min","yOffset","worldStarts","deviceStarts","formatNumber","round","toString","drawAxisLabel","label","offsetX","measureText","fillStyle","fillRect","fillText","GridCanvas","props","canvasRef","increments","useEffect","data","clearRect","textBaseline","textAlign","font","labelY","halfInc","strokeRect","labelX","drawGraph","ref","className","PlotCanvas","lineType","isCycle","forEach","point","index","style","activePoint","location","arc","PI","fill","drawPoint","scaleViewport","v","ratio","newXExtent","newYExtent","newXMin","newYMin","Graph","windowX","windowY","undefined","setActivePoint","ptrDown","setPtrDown","worldPoints","setWorldPoints","devicePoints","setDevicePoints","ratioX","ratioY","xMin","xMax","yMin","yMax","getRegularViewport","setViewport","lineStyle","setLineStyle","setIsCycle","toWorld","toDevice","tabIndex","onPointerDown","e","clicked","clientX","clientY","newActivePoint","loc","dist","sqrt","distance","onPointerMove","preventDefault","xRatio","movementX","yRatio","movementY","clickedPoint","newWorld","onPointerUp","onDoubleClick","newDevicePoint","onWheel","deltaY","onKeyDown","key","splice","id","onChange","target","value","checked","htmlFor","App","renderApp","ReactDOM","render","window","innerWidth","innerHeight","document","getElementById","addEventListener"],"mappings":"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","file":"static/js/main.6e7fcb94.chunk.js","sourcesContent":["import {Point} from \"./Point\";\r\n\r\n// Algorithm from an excellent post by Lubos Brieda: https://www.particleincell.com/2012/bezier-splines/\r\n// Uses Thomas's Algorithm to compute control points from an array of knots.\r\n// Using each pair of knots as endpoints, generates cubic bezier control points\r\n// Must be performed on X and Y separately!\r\nfunction computeControlPoints(knots: number[]): { cp1: number[], cp2: number[] } {\r\n    // Control point lists.\r\n    // After running, beziers from {knots[i], cp1[i], cp2[i], knots[i + 1]} will form a smooth curve.\r\n    const cp1: number[] = [];\r\n    const cp2: number[] = [];\r\n    const n = knots.length - 1;\r\n\r\n    // rhs vector\r\n    const a: number[] = [];\r\n    const b: number[] = [];\r\n    const c: number[] = [];\r\n    const r: number[] = [];\r\n\r\n    // left most segment\r\n    a[0] = 0;\r\n    b[0] = 2;\r\n    c[0] = 1;\r\n    r[0] = knots[0] + 2 * knots[1];\r\n\r\n    // internal segments\r\n    for (let i = 1; i < n - 1; i++) {\r\n        a[i] = 1;\r\n        b[i] = 4;\r\n        c[i] = 1;\r\n        r[i] = 4 * knots[i] + 2 * knots[i + 1];\r\n    }\r\n\r\n    // right segment\r\n    a[n - 1] = 2;\r\n    b[n - 1] = 7;\r\n    c[n - 1] = 0;\r\n    r[n - 1] = 8 * knots[n - 1] + knots[n];\r\n\r\n    // solves Ax=b with the Thomas algorithm (from Wikipedia)\r\n    for (let i = 1; i < n; i++) {\r\n        const m = a[i] / b[i - 1];\r\n        b[i] = b[i] - m * c[i - 1];\r\n        r[i] = r[i] - m * r[i - 1];\r\n    }\r\n\r\n    cp1[n - 1] = r[n - 1] / b[n - 1];\r\n    for (let i = n - 2; i >= 0; --i)\r\n        cp1[i] = (r[i] - c[i] * cp1[i + 1]) / b[i];\r\n\r\n    //we have p1, now compute p2\r\n    for (let i = 0; i < n - 1; i++)\r\n        cp2[i] = 2 * knots[i + 1] - cp1[i + 1];\r\n\r\n    cp2[n - 1] = 0.5 * (knots[n] + cp1[n - 1]);\r\n\r\n    return {cp1: cp1, cp2: cp2};\r\n}\r\n\r\n// TODO: Add separate algorithm that correctly handles closed curves (loops)\r\n// See http://www.jacos.nl/jacos_html/spline/circular/index.html\r\nexport function fitCurve(points: Point[]): Point[] {\r\n    if(points.length < 3) return points;\r\n\r\n    const xCPs = computeControlPoints(points.map(p => p.x));\r\n    const yCPs = computeControlPoints(points.map(p => p.y));\r\n\r\n    const cubicCPs: Point[] = [points[0]];\r\n    for(let i = 0; i < points.length - 1; i++) {\r\n        cubicCPs.push({x: xCPs.cp1[i], y: yCPs.cp1[i]});\r\n        cubicCPs.push({x: xCPs.cp2[i], y: yCPs.cp2[i]});\r\n        cubicCPs.push(points[i + 1]);\r\n    }\r\n\r\n    return cubicCPs;\r\n}","import {Point} from './Point';\r\nimport {LineStyle} from \"./types\";\r\nimport {fitCurve} from \"./fitcurve\";\r\n\r\nexport const radius: number = 8;\r\n\r\nexport function drawPoint(ctx: CanvasRenderingContext2D, location: Point, style: string) {\r\n    ctx.fillStyle = style;\r\n    ctx.beginPath();\r\n    ctx.arc(location.x, location.y, radius, 0, Math.PI * 2);\r\n    ctx.fill();\r\n}\r\n\r\n// Minor lines are used for handles etc\r\nfunction connectPts(ctx: CanvasRenderingContext2D, points: Point[], cycle: boolean, minor: boolean) {\r\n    if (points.length < 2) return;\r\n\r\n    const first = points[0];\r\n    let cur;\r\n\r\n    ctx.beginPath();\r\n    if (minor) {\r\n        ctx.strokeStyle = 'gray';\r\n        ctx.lineWidth = 0.5;\r\n    }\r\n\r\n    ctx.moveTo(first.x, first.y);\r\n    for (let i = 1; i < points.length; i++) {\r\n        cur = points[i];\r\n        ctx.lineTo(cur.x, cur.y);\r\n    }\r\n\r\n    if (cycle) ctx.lineTo(first.x, first.y);\r\n\r\n    ctx.stroke();\r\n    if (minor) {\r\n        ctx.strokeStyle = 'black';\r\n        ctx.lineWidth = 1;\r\n    }\r\n}\r\n\r\nfunction drawBezier(ctx: CanvasRenderingContext2D, start: Point, cp1: Point, cp2: Point, end: Point) {\r\n    ctx.beginPath();\r\n    ctx.moveTo(start.x, start.y);\r\n    ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, end.x, end.y);\r\n    ctx.stroke();\r\n}\r\n\r\nfunction drawQuadratic(ctx: CanvasRenderingContext2D, start: Point, cp: Point, end: Point) {\r\n    ctx.beginPath();\r\n    ctx.moveTo(start.x, start.y);\r\n    ctx.quadraticCurveTo(cp.x, cp.y, end.x, end.y);\r\n    ctx.stroke();\r\n}\r\n\r\nfunction piecewiseCubicBezier(ctx: CanvasRenderingContext2D, points: Point[], drawHandles: boolean) {\r\n    for (let i = 0; i < points.length;) {\r\n        const left = points.length - i;\r\n        const start: Point = points[i];\r\n        if (left >= 4) {\r\n            const cp1 = points[i + 1];\r\n            const cp2 = points[i + 2];\r\n            const end = points[i + 3];\r\n            if(drawHandles) connectPts(ctx, [start, cp1, cp2, end], false, true);\r\n            drawBezier(ctx, start, cp1, cp2, end);\r\n            i += 3;\r\n        } else if (left === 3) {\r\n            const cp = points[i + 1];\r\n            const end = points[i + 2];\r\n            if(drawHandles) connectPts(ctx, [start, cp, end], false, true);\r\n            drawQuadratic(ctx, start, cp, end);\r\n            i += 2;\r\n        } else if (left === 2) {\r\n            const end = points[i + 1];\r\n            connectPts(ctx, [start, end], false, false);\r\n            i++;\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n}\r\n\r\nexport function drawLine(ctx: CanvasRenderingContext2D, points: Point[], type: LineStyle, cycle: boolean) {\r\n    if(cycle) {\r\n        points = points.slice();\r\n        points.push(points[0]);\r\n    }\r\n\r\n    switch (type) {\r\n        case 'spline':\r\n            const cps = fitCurve(points);\r\n            piecewiseCubicBezier(ctx, cps, false);\r\n            break;\r\n        case 'bezier':\r\n            piecewiseCubicBezier(ctx, points, true) ;\r\n            break;\r\n        case 'line':\r\n            connectPts(ctx, points, false, false);\r\n            break;\r\n        default: // Do nothing with plot types\r\n            break;\r\n    }\r\n}\r\n\r\n\r\n","import {useCallback, useState} from \"react\";\r\n\r\nexport type CanvasRefs = [CanvasRenderingContext2D | null, (canvas: HTMLCanvasElement) => void];\r\n\r\n// We use a callback hook to store the context as state\r\n// This avoids calling ref.getContext every time we update the canvas\r\nexport function useCanvasRefs(): CanvasRefs {\r\n    const [ctx, setCtx] = useState<CanvasRenderingContext2D | null>(null);\r\n    // Called when a canvas is mounted\r\n    const callback = useCallback((canvas: HTMLCanvasElement) => {\r\n        if (canvas !== null) {\r\n            setCtx(canvas.getContext('2d'));\r\n        }\r\n    }, []);\r\n\r\n    return [ctx, callback];\r\n}\r\n","import React, {useEffect} from 'react';\r\nimport {useCanvasRefs} from \"./hooks\";\r\nimport {Viewport, GraphData} from \"./types\";\r\n\r\ntype GraphBackgroundProps = {\r\n    width: number,\r\n    height: number,\r\n    viewport: Viewport\r\n};\r\n\r\n// Pick the largest tick increment which is 1, 2, or 5 times a power of 10\r\nfunction getIncrement(minTicks: number, span: number): number {\r\n    const log = Math.log10(span / minTicks);\r\n\r\n    const pow10 = Math.pow(10, Math.floor(log));\r\n    const div = span / (pow10 * minTicks);\r\n\r\n    if (div > 5) return pow10 * 5;\r\n    if (div > 2) return pow10 * 2;\r\n    return pow10;\r\n}\r\n\r\nfunction getIncrements(viewport: Viewport, width: number, height: number): GraphData {\r\n    const minTicks: number = 14;\r\n\r\n    //const worldIncrements = {dx: getIncrement(minTicks, xSpan), dy: getIncrement(minTicks, ySpan)};]\r\n    const span = Math.max(viewport.x.extent, viewport.y.extent);\r\n    const inc = getIncrement(minTicks, span);\r\n    const worldIncrements = {dx: inc, dy: inc};\r\n    const deviceDX = width / (viewport.x.extent / worldIncrements.dx);\r\n    const deviceDY = height / (viewport.y.extent / worldIncrements.dy);\r\n    const deviceIncrements = {dx: deviceDX, dy: deviceDY};\r\n\r\n    // First tick is usually not exactly at the baseline\r\n    let xOffset = Math.abs(viewport.x.min) % inc;\r\n    let yOffset = Math.abs(viewport.y.min) % inc;\r\n\r\n    xOffset = viewport.x.min > 0 ? -xOffset : xOffset;\r\n    yOffset = viewport.y.min > 0 ? -yOffset : yOffset;\r\n\r\n    // First tick is at min + offset\r\n    const worldStarts = {x: xOffset + viewport.x.min, y: yOffset + viewport.y.min};\r\n    const deviceStarts = {x: xOffset / viewport.x.extent * width, y: yOffset / viewport.y.extent * height};\r\n\r\n    return {worldStarts, deviceStarts, worldIncrements, deviceIncrements};\r\n}\r\n\r\n// Format the number, chop off rounding errors, etc\r\n// TODO: find complete solution that dodges floating point issues; as this one fails due to rounding and at certain sizes\r\n// Possibility: store the increment as an int, multiply by tick amount, then manually add zeroes on either side\r\nfunction formatNumber(n: number): string {\r\n    return (Math.round(n * 1000) / 1000).toString();\r\n}\r\n\r\nfunction drawAxisLabel(ctx: CanvasRenderingContext2D, label: string, x: number, y: number, offsetX: boolean): void {\r\n    const m: TextMetrics = ctx.measureText(label);\r\n    if(offsetX) x += m.width / 2;\r\n    ctx.fillStyle = 'white';\r\n    ctx.fillRect(x - m.width / 2, y - 8, m.width, 16);\r\n    ctx.fillStyle = 'black';\r\n    ctx.fillText(label, x, y);\r\n}\r\n\r\nfunction drawGraph(ctx: CanvasRenderingContext2D, width: number, height: number, data: GraphData) {\r\n    if (ctx === null) return;\r\n\r\n    ctx.clearRect(0, 0, width, height);\r\n    ctx.strokeStyle = 'gray';\r\n    ctx.textBaseline = 'middle';\r\n    ctx.textAlign = 'center';\r\n    ctx.font = '16px monospace';\r\n\r\n    // Do Y axis first so the horizontal gridlines get cleared properly by drawAxisLabel\r\n    // TODO: figure out better solution for labeling\r\n    let labelY = data.worldStarts.y;\r\n    let halfInc = data.worldIncrements.dy / 2;\r\n    for (let y = height - data.deviceStarts.y; y >= 0; y -= data.deviceIncrements.dy) {\r\n        if (labelY + halfInc > 0 && labelY - halfInc < 0) {\r\n            ctx.strokeStyle = 'black';\r\n            ctx.strokeRect(0, y, width, 0.8);\r\n            ctx.strokeStyle = 'gray';\r\n        } else {\r\n            ctx.strokeRect(0, y, width, 0.1);\r\n        }\r\n\r\n        drawAxisLabel(ctx, formatNumber(labelY), 0, y, true);\r\n        labelY += data.worldIncrements.dy;\r\n    }\r\n\r\n    let labelX = data.worldStarts.x;\r\n    halfInc = data.worldIncrements.dx / 2;\r\n    for (let x = data.deviceStarts.x; x < width; x += data.deviceIncrements.dx) {\r\n        if (labelX + halfInc > 0 && labelX - halfInc < 0) {\r\n            ctx.strokeStyle = 'black';\r\n            ctx.strokeRect(x, 0, 0.8, height);\r\n            ctx.strokeStyle = 'gray';\r\n        } else {\r\n            ctx.strokeRect(x, 0, 0.1, height);\r\n        }\r\n\r\n        drawAxisLabel(ctx, formatNumber(labelX), x, 10, false);\r\n        labelX += data.worldIncrements.dx;\r\n    }\r\n}\r\n\r\nconst GridCanvas: React.FC<GraphBackgroundProps> = (props: GraphBackgroundProps) => {\r\n    const [ctx, canvasRef] = useCanvasRefs();\r\n    const increments = getIncrements(props.viewport, props.width, props.height);\r\n\r\n    useEffect(() => {\r\n        if (ctx === null) return;\r\n        drawGraph(ctx, props.width, props.height, increments);\r\n    }, [ctx, props, increments]);\r\n\r\n    return <canvas\r\n        ref={canvasRef}\r\n        width={props.width}\r\n        height={props.height}\r\n        className='fixed layer-bottom'\r\n    />\r\n};\r\n\r\nexport default GridCanvas;","import React, {useEffect} from 'react';\r\nimport {Point} from \"./Point\";\r\nimport {useCanvasRefs} from \"./hooks\";\r\nimport {drawLine, drawPoint} from './Draw';\r\nimport {LineStyle} from \"./types\";\r\n\r\ntype PlotCanvasProps = {\r\n    width: number,\r\n    height: number,\r\n    points: Point[],\r\n    activePoint: number | undefined,\r\n    lineType: LineStyle,\r\n    isCycle: boolean\r\n};\r\n\r\nconst PlotCanvas: React.FC<PlotCanvasProps> = (props: PlotCanvasProps) => {\r\n    const [ctx, canvasRef] = useCanvasRefs();\r\n\r\n    useEffect(() => {\r\n        if (ctx === null || props.points.length === 0) return;\r\n\r\n        ctx.clearRect(0, 0, props.width, props.height);\r\n        drawLine(ctx, props.points, props.lineType, props.isCycle);\r\n        props.points.forEach((point, index) => {\r\n            let style: string;\r\n            if (index === props.activePoint) {\r\n                style = 'red';\r\n            } else {\r\n                style = 'blue';\r\n            }\r\n\r\n            drawPoint(ctx, point, style);\r\n        });\r\n    }, [ctx, props]);\r\n\r\n    return <canvas\r\n        ref={canvasRef}\r\n        width={props.width}\r\n        height={props.height}\r\n        className='fixed layer-middle'\r\n    />\r\n};\r\n\r\nexport default PlotCanvas;","import React, {useCallback, useEffect, useState} from 'react';\r\nimport {Point, distance} from './Point';\r\nimport {radius} from './Draw';\r\nimport GridCanvas from './GridCanvas';\r\nimport PlotCanvas from './PlotCanvas';\r\nimport {Dimensions, LineStyle, Viewport} from \"./types\";\r\n\r\nfunction getRegularViewport(min: number, max: number, windowX: number, windowY: number): Viewport {\r\n    let ratioX: number = 1;\r\n    let ratioY: number = 1;\r\n    if (windowX > windowY) {\r\n        ratioY = windowY / windowX;\r\n    } else {\r\n        ratioX = windowX / windowY;\r\n    }\r\n\r\n    const xMin = min * ratioX;\r\n    const xMax = max * ratioX;\r\n    const yMin = min * ratioY;\r\n    const yMax = max * ratioY;\r\n\r\n    return {\r\n        x: {min: xMin, max: xMax, extent: xMax - xMin},\r\n        y: {min: yMin, max: yMax, extent: yMax - yMin}\r\n    };\r\n}\r\n\r\nfunction getDefaultViewport(windowX: number, windowY: number): Viewport {\r\n    return getRegularViewport(-10.5, 10.5, windowX, windowY);\r\n}\r\n\r\nfunction scaleViewport(v: Viewport, ratio: number) {\r\n    const newXExtent = v.x.extent * ratio;\r\n    const newYExtent = v.y.extent * ratio;\r\n    const newXMin = (v.x.extent - newXExtent) / 2 + v.x.min;\r\n    const newYMin = (v.y.extent - newYExtent) / 2 + v.y.min;\r\n\r\n    return {\r\n        x: {min: newXMin, max: newXMin + newXExtent, extent: newXExtent},\r\n        y: {min: newYMin, max: newYMin + newYExtent, extent: newYExtent}\r\n    };\r\n}\r\n\r\nconst Graph: React.FC<Dimensions> = (props: Dimensions) => {\r\n    const [activePoint, setActivePoint] = useState<number | undefined>(undefined);\r\n    const [ptrDown, setPtrDown] = useState<boolean>(false);\r\n    const [worldPoints, setWorldPoints] = useState<Point[]>([]);\r\n    const [devicePoints, setDevicePoints] = useState<Point[]>([]);\r\n    const [viewport, setViewport] = useState<Viewport>(getDefaultViewport(props.width, props.height));\r\n    const [lineStyle, setLineStyle] = useState<LineStyle>('spline');\r\n    const [isCycle, setIsCycle] = useState<boolean>(false);\r\n\r\n    // We store world coordinates and convert back to device coordinates to display\r\n    function toWorld(point: Point): Point {\r\n        return {\r\n            x: point.x / props.width * viewport.x.extent + viewport.x.min,\r\n            y: (props.height - point.y) / props.height * viewport.y.extent + viewport.y.min\r\n        };\r\n    }\r\n\r\n    // We wrap toDevice conversion with useCallback so that the useEffect below has static dependencies\r\n    const toDevice = useCallback((point: Point) => {\r\n        return {\r\n            x: Math.round((point.x - viewport.x.min) / viewport.x.extent * props.width),\r\n            y: Math.round(props.height - ((point.y - viewport.y.min) / viewport.y.extent * props.height))\r\n        };\r\n    }, [props.width, props.height, viewport]);\r\n\r\n    // When worldPoints changes, update devicePoints to trigger a redraw\r\n    useEffect(() => {\r\n        setDevicePoints(worldPoints.map(toDevice));\r\n    }, [toDevice, worldPoints]);\r\n\r\n    function handlePointerDown(e: React.PointerEvent) {\r\n        // Set the active point\r\n        // New active point should be the one closest to click, but only if a point is close enough\r\n        let min: number = radius;\r\n        const clicked: Point = {x: e.clientX, y: e.clientY};\r\n        let newActivePoint: number | undefined = undefined;\r\n        devicePoints.forEach((loc, index) => {\r\n            const dist = distance(clicked, loc);\r\n            if (dist < min) {\r\n                newActivePoint = index;\r\n                min = dist;\r\n            }\r\n        });\r\n\r\n        if (activePoint !== newActivePoint) {\r\n            setActivePoint(newActivePoint);\r\n        }\r\n\r\n        setPtrDown(true);\r\n    }\r\n\r\n    function handlePointerMove(e: React.PointerEvent) {\r\n        if (!ptrDown) return;\r\n\r\n        // Prevents undesired drag behavior on Chrome\r\n        e.preventDefault();\r\n\r\n        if (activePoint === undefined) { // Pan the graph\r\n            const xRatio = e.movementX / props.width;\r\n            const dx = (viewport.x.max - viewport.x.min) * xRatio;\r\n            const xMin = viewport.x.min - dx;\r\n            const xMax = viewport.x.max - dx;\r\n\r\n            const yRatio = e.movementY / props.height;\r\n            const dy = (viewport.y.max - viewport.y.min) * yRatio;\r\n            const yMin = viewport.y.min + dy;\r\n            const yMax = viewport.y.max + dy;\r\n\r\n            setViewport({\r\n                x: {min: xMin, max: xMax, extent: xMax - xMin},\r\n                y: {min: yMin, max: yMax, extent: yMax - yMin}\r\n            });\r\n        } else { // Move the point\r\n            // TODO: optimization: use reducer for points since useState does not merge lists\r\n            const clickedPoint = {x: e.clientX, y: e.clientY};\r\n            const newWorld = worldPoints.slice();\r\n            newWorld[activePoint] = toWorld(clickedPoint);\r\n\r\n            setWorldPoints(newWorld);\r\n        }\r\n    }\r\n\r\n    function handlePointerUp(e: React.PointerEvent) {\r\n        setPtrDown(false);\r\n    }\r\n\r\n    function handleDoubleClick(e: React.MouseEvent) {\r\n        const newDevicePoint: Point = {x: e.clientX, y: e.clientY};\r\n        setActivePoint(worldPoints.length);\r\n        setDevicePoints([...devicePoints, newDevicePoint]);\r\n        setWorldPoints([...worldPoints, toWorld(newDevicePoint)]);\r\n    }\r\n\r\n    function handleWheel(e: React.WheelEvent) {\r\n        if (e.deltaY === 0) return;\r\n\r\n        if (e.deltaY > 0) { // Scroll down: zoom out\r\n            setViewport(scaleViewport(viewport, 1.2));\r\n        } else { // Scroll up: zoom in\r\n            setViewport(scaleViewport(viewport, 0.8));\r\n        }\r\n    }\r\n\r\n    function handleKeyDown(e: React.KeyboardEvent) {\r\n        switch (e.key) {\r\n            case 'd' || 'D': // Delete the active point\r\n                if (activePoint !== undefined) {\r\n                    devicePoints.splice(activePoint, 1);\r\n                    worldPoints.splice(activePoint, 1);\r\n                    setDevicePoints(devicePoints);\r\n                    setWorldPoints(worldPoints);\r\n                    setActivePoint(undefined);\r\n                }\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n\r\n    return <>\r\n        <div\r\n            style={{\r\n                width: props.width,\r\n                height: props.height\r\n            }}\r\n            tabIndex={0} // So we can focus the div and get keyboard events\r\n            onPointerDown={handlePointerDown}\r\n            onPointerMove={handlePointerMove}\r\n            onPointerUp={handlePointerUp}\r\n            onDoubleClick={handleDoubleClick}\r\n            onWheel={handleWheel}\r\n            onKeyDown={handleKeyDown}\r\n            className='fixed layer-top'\r\n        />\r\n        <GridCanvas\r\n            width={props.width}\r\n            height={props.height}\r\n            viewport={viewport}\r\n        />\r\n        <PlotCanvas\r\n            width={props.width}\r\n            height={props.height}\r\n            points={devicePoints}\r\n            activePoint={activePoint}\r\n            lineType={lineStyle}\r\n            isCycle={isCycle}\r\n        />\r\n        <div\r\n            id='controls'\r\n            className='layer-control'\r\n        >\r\n            <select\r\n                id='line-style'\r\n                onChange={e => {\r\n                    setLineStyle(e.target.value as LineStyle);\r\n                }}\r\n            >\r\n                <option value={'spline'}>Spline</option>\r\n                <option value={'bezier'}>Bezier</option>\r\n                <option value={'line'}>Line</option>\r\n                <option value={'plot'}>Plot</option>\r\n            </select>\r\n            <div>\r\n                <input type='checkbox'\r\n                       onChange={e => {\r\n                           setIsCycle(e.target.checked);\r\n                       }}\r\n                />\r\n                <label htmlFor='cycle'>Cycle</label>\r\n            </div>\r\n        </div>\r\n    </>\r\n};\r\n\r\nexport default Graph;","export interface Point {\r\n    x: number;\r\n    y: number;\r\n}\r\n\r\nexport function distance(a: Point, b: Point) : number {\r\n    const dx = b.x - a.x;\r\n    const dy = b.y - a.y;\r\n    return Math.sqrt(dx * dx + dy * dy);\r\n}\r\n","import React from 'react';\nimport Graph from './Graph';\nimport './App.css';\n\ninterface WindowDimensions {\n    width: number;\n    height: number;\n}\n\nconst App: React.FC<WindowDimensions> = (props: WindowDimensions) => {\n    return (\n        <>\n            <Graph\n                width={props.width}\n                height={props.height}\n            />\n        </>\n    );\n};\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nfunction renderApp() {\n    ReactDOM.render(<App width={window.innerWidth} height={window.innerHeight} />, document.getElementById('root'));\n}\n\nwindow.addEventListener('resize', renderApp);\n\nrenderApp();\n"],"sourceRoot":""}